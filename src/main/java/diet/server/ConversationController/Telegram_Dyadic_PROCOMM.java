/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package diet.server.ConversationController;

import diet.attribval.AttribVal;
import diet.server.Conversation;
import diet.server.ConversationController.ui.CustomDialog;
import diet.server.ConversationController.ui.JInterfaceMenuButtonsReceiverInterface;
import diet.server.ConversationController.ui.JInterfaceTenButtons;
import diet.server.Participant;
import diet.task.ProceduralComms.PCTaskTG;
import diet.task.ProceduralComms.Pair;
import diet.task.ProceduralComms.Quad;
import diet.tg.TelegramMessageFromClient;
import diet.tg.TelegramParticipant;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.util.Collections;
import java.util.Hashtable;
import java.util.Vector;
import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.TitledBorder;
import org.telegram.telegrambots.meta.api.objects.Message;

/**
 *
 * @author LX1C
 */
public class Telegram_Dyadic_PROCOMM extends TelegramController implements JInterfaceMenuButtonsReceiverInterface{

    //// 31685435608
     // 31686348684
    
    
   //Quad of 4
   //Start with practice                                                                             (DONE)
   //Practice is unbounded                                                                           (DONE)
   //button to swap within  (check is in experiment mode before swap)                                (DONE)
   //button to swap between (Check is in experiment mode before swap)                            
   //code that makes other appear as participant X                                                   (DONE)
   //Need to be able to see what level they are at and what practice level they have achieved        
   //The experiment size needs to be bounded....in terms of the maximum length of the sequence       (DONE)
   // Make sure it scores points correctly
   // Make it do the timeout for simultaneous moves correctly 
   // Check that timeouts (AND DIFFERENT / AND SAME) that it displays that info in the text area
   // Check that winning streaks are displayed in the text area
   // Check that losses and decrease of level are displayed in the text area
   // 
   // Fix the partnernames so that they are all from a random list of names  
   // The name generated by Swapstate is potentially buggy...is the same name used for all quads?
   // The swapstate variable could be made static...or it could be totally random...
    
   //Quad of 8
   //Wire up so that it can do the same as quad of 4.
   //Automate the timing of swaps...
   //Needs to be able to swap between the 8
   //The timing needs to be done so that the swap doesn`t deadlock with the other timer!
   //   It will need to simultaneously acquire locks on ALL the PCTaskTG ...and only then do the swap...
   //   Should kill be synchronized in PCTaskTG
   //   Should kill remove reference to cC (instantly)? 
   // 
   //Sorts through list of participants in Telegram ID order (So that it can be restarted in case of crash)
   //Loads highest level to datafile (so can be recovered from crash)
   //TEST CRASH RESISTANCE
   //
   //The practice stage is used to make sure that participant technology works...IF they don`t get to a certain point, then they can be excluded...and experiment restarted....
    //Add functionality where when you do group assignment, it activates that in the ConversationController
    
    //Make it save in the CSV what the quad is and the swapstate

    //Need to add an option for 4 participants - ALL WITHIN
    //Need to add an option for 8 participants - ALL BETWEEN, NO WITHIN
    //Need to add an option for 12 participant
    
    
    // Check that the swap swaps at the right level...give output at each stage. CHECK IT!
    
    // Check relogin with 12. Make it relogon safe..SORT BY ORDER...
    
    
    //
    // Make it so that it records the number of points of each person and pair..
    //
    //Make it so that in the first game it ranks them by level....so that there is one quad with the w
    
    
    // Check the output file! Who was interacting with whom..  
    
    //
    //
    // Needs to have "joker" participant so that if there are 9,11,13,15,17,19 participants...they participate....OR alternatively simply get told to wait...
    
    
   //Needs to sort through IDs numerically and then assign themst be unbou
    //Practice game must be unbounded...
    //
    //Needs to be able to start with...
    //Must NOT be able to
    //Then automate the swapping...within AND between
    //Then be able to deal with
    
    JFrame jfUIQuads;
    JFrame jfUISolitaryPairs;
    JFrame jfUIBETWEENPairs;
    
    JInterfaceTenButtons jitb = new JInterfaceTenButtons (this, "assign to initial quads and pairs", "start experiment", "start timer", "pause timer"   ,"swap within","swap between","","","","");
    
    public Telegram_Dyadic_PROCOMM(Conversation c) {
        super(c);
        
    }

    public Telegram_Dyadic_PROCOMM(Conversation c, long istypingtimeout) {
        super(c, istypingtimeout);
        
        
    }

    
    
     //Quad q;
    // Pair p;
    
     
     Vector<Pair> solitaryPairs = new Vector();
     Vector<Pair> betweenPairs = new Vector();
     Vector<Quad> quads = new Vector();
    
    public void assignToInitialQuadsAndPairs(){
         Vector<TelegramParticipant> v = (Vector)c.getParticipants().getAllParticipantsNewCopy().clone();
         Collections.sort(v);
         //If size == 2 . Pairs
         //If size == 3.  Pairs and one gets thrown out
         //If size == 4.  One quad
         //If size == 5.  One quad and one gets thrown out
         //If size == 6.  One quad and one pair
         
         while(v.size()>=4){
             TelegramParticipant tp1 = v.elementAt(0);
             TelegramParticipant tp2 = v.elementAt(1);
             TelegramParticipant tp3 = v.elementAt(2);
             TelegramParticipant tp4 = v.elementAt(3);
             
             Conversation.printWSln("Main", "Creating a quad with "+tp1.getConnection().telegramID+", "+tp2.getConnection().telegramID+", "+tp3.getConnection().telegramID+", "+tp4.getConnection().telegramID);
             Quad q = new Quad(this,tp1,tp2,tp3,tp4);
             quads.add(q);
             
             v.remove(tp1);
             v.remove(tp2);
             v.remove(tp3);
             v.remove(tp4);
             
         }
         
         while(v.size()>=2){
             
             TelegramParticipant tp1 = v.elementAt(0);
             TelegramParticipant tp2 = v.elementAt(1);
             
             Conversation.printWSln("Main", "Creating a pair with "+tp1.getConnection().telegramID+", "+tp2.getConnection().telegramID);
             
             Pair p = new Pair(this,tp1,tp2,0,true,false);  //0 because it is initial
             solitaryPairs.add(p);
             
             v.remove(tp1);
             v.remove(tp2);
             
         }
         
         if(v.size()>0){
             CustomDialog.showDialog("There are "+v.size()+ " participants left over\n");
             
         }
         
         
        this.buildUIQUAD();
        this.buildUISOLITARYPAIR();
        
        
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    @Override
    public void performActionTriggeredByUI(String s) {
      
        
       if(s.equalsIgnoreCase("assign to initial quads and pairs")){
           if(c.getParticipants().getAllParticipants().size()<2){
               CustomDialog.showDialog("Can`t initialize. Fewer than two participants logged in");
               return;
           }
           this.assignToInitialQuadsAndPairs();
       }
        
        
       else if(s.equalsIgnoreCase("swap within")){
       
            try{
                //Thread.sleep(5000);
                for(int i=0;i<quads.size();i++){
                    quads.elementAt(i).swapWITHIN();
                }
                buildUIQUAD();
                
                for(int i=0;i<solitaryPairs.size();i++){
                    solitaryPairs.elementAt(i).swap();
                }
                buildUISOLITARYPAIR();
            
            }catch(Exception e){e.printStackTrace();}         
        }
         else if (s.equalsIgnoreCase("swap between")){
            boolean cont = CustomDialog.getBoolean("Perform the swap BETWEEN THE GROUPS?", "SWAP", "CANCEL");
            if(!cont)return;
             
            int swapState = 100;
            if(quads.size()==0){
                CustomDialog.showDialog("No Between Swapping actually done. There are no quads");
            }
            else if (quads.size()==1){
                TelegramParticipant[] tps = quads.elementAt(0).swapBETWEEN();
                swapState = quads.elementAt(0).getSwapState();
                Pair p = new Pair(this,tps[0],tps[1],swapState,false,true);
                this.betweenPairs.add(p);
                
            }
            else if (quads.size()==2){
                TelegramParticipant[] tpsA = quads.elementAt(0).swapBETWEEN();
                TelegramParticipant[] tpsB = quads.elementAt(1).swapBETWEEN();
                
                swapState = quads.elementAt(0).getSwapState();
                
                Pair pA = new Pair(this,tpsA[0],tpsB[0],swapState,false,true);
                Pair pB = new Pair(this,tpsA[1],tpsB[1],swapState,false,true);
                this.betweenPairs.add(pA);
                this.betweenPairs.add(pB);
                
            }
             else if (quads.size()==3){
                TelegramParticipant[] tpsA = quads.elementAt(0).swapBETWEEN();
                TelegramParticipant[] tpsB = quads.elementAt(1).swapBETWEEN();
                TelegramParticipant[] tpsC = quads.elementAt(2).swapBETWEEN();
                
                swapState = quads.elementAt(0).getSwapState();
                
                Pair pA = new Pair(this,tpsA[1],tpsC[0],swapState,false,true);
                Pair pB = new Pair(this,tpsB[1],tpsA[0],swapState,false,true);
                Pair pC = new Pair(this,tpsC[1],tpsB[0],swapState,false,true);
                
                this.betweenPairs.add(pA);
                this.betweenPairs.add(pB);
                this.betweenPairs.add(pC);
                
            }
            
           for(int i=0;i<this.solitaryPairs.size();i++){
               this.solitaryPairs.elementAt(i).swap();
           }
            
           // Need to do within for  solitarypairs so they think they have swapped
            
                    
           
          this.buildUIQUAD();
          this.buildUIBETWEENPAIR();
          this.buildUISOLITARYPAIR();
             
          

        }
       
        
        else if (s.equalsIgnoreCase("start experiment")){
            
             for(int i=0;i<quads.size();i++){
                    quads.elementAt(i).startEXPERIMENT();
             }
             buildUIQUAD();
            
             for(int i=0;i<solitaryPairs.size();i++){
                    solitaryPairs.elementAt(i).startEXPERIMENT();
             }
             buildUISOLITARYPAIR();
             
        }
        
        
        else if (s.equalsIgnoreCase("start timer")){
             for(int i=0;i<quads.size();i++){
                    quads.elementAt(i).startTIMER();
             }
             buildUIQUAD();
            
             for(int i=0;i<solitaryPairs.size();i++){
                    solitaryPairs.elementAt(i).startTIMER();
             }
             buildUISOLITARYPAIR();
        }
        else if(s.equalsIgnoreCase("pause timer")){
            for(int i=0;i<quads.size();i++){
                    quads.elementAt(i).startTIMER();
             }
             buildUIQUAD();
            
             for(int i=0;i<solitaryPairs.size();i++){
                    solitaryPairs.elementAt(i).pauseTIMER();
             }
             buildUISOLITARYPAIR();
        }
        
        else if (s.equalsIgnoreCase("send explanation once")){
            //pctg.sendInstructionsOnce();
        }
        
        
        
    }

    
    
    
    
    
    

   
     public void telegram_participantJoinedConversation(TelegramParticipant p) {
              
        this.generatePinnedMessage(p);
         
        if(c.getParticipants().getAllParticipants().size()==4) {
            
             //pp.createNewSubdialogue(c.getParticipants().getAllParticipants());
               
             //CustomDialog.showDialog("PRESS OK TO START!");
             //this.experimentHasStarted=true;
             
             //q = new Quad(this,(TelegramParticipant)c.getParticipants().getAllParticipants().elementAt(0), (TelegramParticipant)c.getParticipants().getAllParticipants().elementAt(1),
              //       (TelegramParticipant)c.getParticipants().getAllParticipants().elementAt(2), (TelegramParticipant)c.getParticipants().getAllParticipants().elementAt(3));
             
             //buildUIQUAD();
             
        }
       
    }
    
     
     
     
     
     
     
     
      public void buildUISOLITARYPAIR(){
         
         if(SwingUtilities.isEventDispatchThread()){
            if(jfUISolitaryPairs!=null){
                try{ jfUISolitaryPairs.dispose();}catch(Exception e){e.printStackTrace(); }
             }
             jfUISolitaryPairs = new JFrame();
             for(int i = 0; i < this.solitaryPairs.size();i++){
                 Pair p = solitaryPairs.elementAt(i);
                 JPanel jpp = new JPanel();      
                 TitledBorder title;
                 title = BorderFactory.createTitledBorder("Solitary pair: "+i);
                 jpp.setBorder(title);               
                 jpp.setLayout(new BorderLayout());
                
                 JPanel jpui = p.getUI();
                 jpp.add(jpui, BorderLayout.CENTER);              
                 jfUISolitaryPairs.getContentPane().add(jpp);
             }
             jfUISolitaryPairs.pack();
             jfUISolitaryPairs.setVisible(true);
             positionInBottomLeft(jfUISolitaryPairs);
         }
         else{
             try{
             SwingUtilities.invokeAndWait(new Runnable(){
                 public void run(){
                     if(jfUISolitaryPairs!=null){
                try{ jfUISolitaryPairs.dispose();}catch(Exception e){e.printStackTrace(); }
             }
             jfUISolitaryPairs = new JFrame();
             for(int i = 0; i < solitaryPairs.size();i++){
                 Pair p = solitaryPairs.elementAt(i);
                 JPanel jpp = new JPanel();      
                 TitledBorder title;
                 title = BorderFactory.createTitledBorder("Solitary pair: "+i);
                 jpp.setBorder(title);               
                 jpp.setLayout(new BorderLayout());
                
                 JPanel jpui = p.getUI();
                 jpp.add(jpui, BorderLayout.CENTER);              
                 jfUISolitaryPairs.getContentPane().add(jpp);
             }
             jfUISolitaryPairs.pack();
             jfUISolitaryPairs.setVisible(true);
             positionInBottomLeft(jfUISolitaryPairs);
                            }
             });
             }catch(Exception e){
                 e.printStackTrace();
                 Conversation.saveErr(e);
                 Conversation.saveErr("ERROR IN BUILDING UI");
               if(jfUISolitaryPairs!=null){
                try{ jfUISolitaryPairs.dispose();}catch(Exception ee){ee.printStackTrace(); }
             }
              jfUISolitaryPairs = new JFrame();
             for(int i = 0; i < this.solitaryPairs.size();i++){
                 Pair p = solitaryPairs.elementAt(i);
                 JPanel jpp = new JPanel();      
                 TitledBorder title;
                 title = BorderFactory.createTitledBorder("Solitary pair: "+i);
                 jpp.setBorder(title);               
                 jpp.setLayout(new BorderLayout());
                
                 JPanel jpui = p.getUI();
                 jpp.add(jpui, BorderLayout.CENTER);              
                 jfUISolitaryPairs.getContentPane().add(jpp);
             }
             jfUISolitaryPairs.pack();
             jfUISolitaryPairs.setVisible(true);
             positionInBottomLeft(jfUISolitaryPairs);
             }
         }
         
         
     }
     
     
     
     
     
     
      
           
      public void buildUIBETWEENPAIR(){
         
         if(SwingUtilities.isEventDispatchThread()){
            if(jfUIBETWEENPairs!=null){
                try{ jfUIBETWEENPairs.dispose();}catch(Exception e){e.printStackTrace(); }
             }
             jfUIBETWEENPairs = new JFrame();
             for(int i = 0; i < this.betweenPairs.size();i++){
                 Pair p = betweenPairs.elementAt(i);
                 JPanel jpp = new JPanel();      
                 TitledBorder title;
                 title = BorderFactory.createTitledBorder("BETWEEN pair: "+i);
                 jpp.setBorder(title);               
                 jpp.setLayout(new BorderLayout());
                
                 JPanel jpui = p.getUI();
                 jpp.add(jpui, BorderLayout.CENTER);              
                 jfUIBETWEENPairs.getContentPane().add(jpp);
             }
             jfUIBETWEENPairs.pack();
             jfUIBETWEENPairs.setVisible(true);
             positionInBottomRight(jfUIBETWEENPairs);
         }
         else{
             try{
             SwingUtilities.invokeAndWait(new Runnable(){
                 public void run(){
            if(jfUIBETWEENPairs!=null){
                try{ jfUIBETWEENPairs.dispose();}catch(Exception e){e.printStackTrace(); }
             }
             jfUIBETWEENPairs = new JFrame();
             for(int i = 0; i < betweenPairs.size();i++){
                 Pair p = betweenPairs.elementAt(i);
                 JPanel jpp = new JPanel();      
                 TitledBorder title;
                 title = BorderFactory.createTitledBorder("BETWEEN pair: "+i);
                 jpp.setBorder(title);               
                 jpp.setLayout(new BorderLayout());
                
                 JPanel jpui = p.getUI();
                 jpp.add(jpui, BorderLayout.CENTER);              
                 jfUIBETWEENPairs.getContentPane().add(jpp);
             }
             jfUIBETWEENPairs.pack();
             jfUIBETWEENPairs.setVisible(true);
             positionInBottomRight(jfUIBETWEENPairs);                       }
             });
             }catch(Exception e){
                 e.printStackTrace();
                 Conversation.saveErr(e);
                 Conversation.saveErr("ERROR IN BUILDING UI");
             if(jfUIBETWEENPairs!=null){
                try{ jfUIBETWEENPairs.dispose();}catch(Exception ee){ee.printStackTrace(); }
             }
             jfUIBETWEENPairs = new JFrame();
             for(int i = 0; i < this.betweenPairs.size();i++){
                 Pair p = betweenPairs.elementAt(i);
                 JPanel jpp = new JPanel();      
                 TitledBorder title;
                 title = BorderFactory.createTitledBorder("BETWEEN pair: "+i);
                 jpp.setBorder(title);               
                 jpp.setLayout(new BorderLayout());
                
                 JPanel jpui = p.getUI();
                 jpp.add(jpui, BorderLayout.CENTER);              
                 jfUIBETWEENPairs.getContentPane().add(jpp);
             }
             jfUIBETWEENPairs.pack();
             jfUIBETWEENPairs.setVisible(true);
             positionInBottomRight(jfUIBETWEENPairs);
             }
         }
         
         
     }
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     public void buildUIQUAD(){
         
         if(SwingUtilities.isEventDispatchThread()){
             if(jfUIQuads!=null){
                try{ jfUIQuads.dispose();}catch(Exception e){e.printStackTrace(); }
             }
             jfUIQuads = new JFrame();
             for(int i = 0; i < this.quads.size();i++){
                 Quad q = quads.elementAt(i);
                 JPanel jpq = new JPanel();      
                 TitledBorder title;
                 title = BorderFactory.createTitledBorder("Quad: "+i);
                 jpq.setBorder(title);               
                 jpq.setLayout(new BorderLayout());
                
                 JPanel jpui = q.getUI();
                 jpq.add(jpui, BorderLayout.CENTER);              
                 jfUIQuads.getContentPane().add(jpq);
             }
             jfUIQuads.pack();
             jfUIQuads.setVisible(true);
             positionInTopRight(jfUIQuads);
         }
         else{
             try{
             SwingUtilities.invokeAndWait(new Runnable(){
                 public void run(){
                   if(jfUIQuads!=null){
                try{ jfUIQuads.dispose();}catch(Exception e){e.printStackTrace(); }
             }
             jfUIQuads = new JFrame();
             for(int i = 0; i < quads.size();i++){
                 Quad q = quads.elementAt(i);
                 JPanel jpq = new JPanel();      
                 TitledBorder title;
                 title = BorderFactory.createTitledBorder("Quad: "+i);
                 jpq.setBorder(title);               
                 jpq.setLayout(new BorderLayout());
                
                 JPanel jpui = q.getUI();
                 jpq.add(jpui, BorderLayout.CENTER);              
                 jfUIQuads.getContentPane().add(jpq);
           }
             jfUIQuads.pack();
             jfUIQuads.setVisible(true);
             positionInTopRight(jfUIQuads);
            
                }
             });
             }catch(Exception e){
                 e.printStackTrace();
                 Conversation.saveErr(e);
                 Conversation.saveErr("ERROR IN BUILDING UI");
                if(jfUIQuads!=null){
                    try{ jfUIQuads.dispose();}catch(Exception ee){ee.printStackTrace(); }
             }
                     if(jfUIQuads!=null){
                try{ jfUIQuads.dispose();}catch(Exception ee){ee.printStackTrace(); }
             }
             jfUIQuads = new JFrame();
             for(int i = 0; i < this.quads.size();i++){
                 Quad q = quads.elementAt(i);
                 JPanel jpq = new JPanel();      
                 TitledBorder title;
                 title = BorderFactory.createTitledBorder("Quad: "+i);
                 jpq.setBorder(title);               
                 jpq.setLayout(new BorderLayout());
                
                 JPanel jpui = q.getUI();
                 jpq.add(jpui, BorderLayout.CENTER);              
                 jfUIQuads.getContentPane().add(jpq);
            }
             jfUIQuads.pack();
             jfUIQuads.setVisible(true);
             positionInTopRight(jfUIQuads);

             }
         }
         
         
     }
     
     
     
     
      public void positionInBottomRight(JFrame jf){
        //if(2<5)return;
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice defaultScreen = ge.getDefaultScreenDevice();
        Rectangle rect = defaultScreen.getDefaultConfiguration().getBounds();
        int x = (int) rect.getMaxX() - jf.getWidth();
        int y = (int)rect.getMaxY() - jf.getHeight();
        jf.setLocation(x, y);
        jf.setVisible(true);
     }
     
     public void positionInBottomLeft(JFrame jf){
        //if(2<5)return;
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice defaultScreen = ge.getDefaultScreenDevice();
        Rectangle rect = defaultScreen.getDefaultConfiguration().getBounds();
        int x = 0;//(int) rect.getMaxX() - jf.getWidth();
        int y = (int)rect.getMaxY() - jf.getHeight();
        jf.setLocation(x, y);
        jf.setVisible(true);
     }
     
     
     
     public void positionInTopRight(JFrame jf){
         GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice defaultScreen = ge.getDefaultScreenDevice();
        Rectangle rect = defaultScreen.getDefaultConfiguration().getBounds();
        int x = (int) rect.getMaxX() - jf.getWidth();
        int y = 40;
        jf.setLocation(x, y);
        jf.setVisible(true);
     }
     
     
     
   
    @Override
    public void telegram_participantReJoinedConversation(TelegramParticipant p) {
        
        this.generatePinnedMessage(p);
        
       
       if(c.getParticipants().getAllParticipants().size()==4) {
            
           //  pp.createNewSubdialogue(c.getParticipants().getAllParticipants());
               
            // CustomDialog.showDialog("PRESS OK TO START!");
            // this.experimentHasStarted=true;
             
             //q = new Quad(this,(TelegramParticipant)c.getParticipants().getAllParticipants().elementAt(0), (TelegramParticipant)c.getParticipants().getAllParticipants().elementAt(1),
             //        (TelegramParticipant)c.getParticipants().getAllParticipants().elementAt(2), (TelegramParticipant)c.getParticipants().getAllParticipants().elementAt(3));
             
             //buildUIQUAD();
             
        }
       
       
    }
     

    @Override
    public synchronized void telegram_processTelegramMessageFromClient(TelegramParticipant sender, TelegramMessageFromClient tmfc) {
        if(tmfc.u.hasMessage()  && tmfc.u.getMessage().hasText()){
             String text = tmfc.u.getMessage().getText();
             
             
             
             if(text.startsWith("/menu")){
                 generatePinnedMessage(sender);
             }
             else{
                 System.err.println("Attempting to acquire lock on pctasktg");
                 
                 // if(q!=null&&q.isParticipantInQuad(sender)) q.evaluate(sender, tmfc);
                 //if(this.pctg!=null) this.pctg.evaluate(sender, tmfc);
                
                 
             }
             
             
        }
        else{
        try{
            Message pm = tmfc.u.getMessage().getPinnedMessage();
            if(pm!=null&&pm.hasText()){
                
            }else{
                 c.telegram_sendInstructionToParticipant_MonospaceFont(sender, "Please only send text");
            }
            
        }catch(Exception e){
               c.telegram_sendInstructionToParticipant_MonospaceFont(sender, "Please only send text");   
               e.printStackTrace();
               Conversation.saveErr(e);
        }
        }        
          

        
    
    }
    
    
    
    
     //PCTaskTG pctg;
     public Hashtable htPinnedMessages = new Hashtable();
     public Hashtable<TelegramParticipant,String> htMostRecentPinnedText = new Hashtable();
    
    
    public void generatePinnedMessage(TelegramParticipant p){ 
        if(p==null){
            Conversation.saveErr("Trying to generate pinned message for null participant");
            return;
        }
        Message m = c.telegram_sendInstructionToParticipant_MonospaceFont(p, "Please do not close this message. You will need it in the task");
        c.telegram_sendPinChatMessageToParticipant(p, m);
        htPinnedMessages.put(p, m);      
    }
    
    
    
    
    public void changePinnedMessage(TelegramParticipant p,String text){
        System.err.println("CHANGEPINNEDMESSAGE1"+text);
         if(p==null){
            Conversation.saveErr("Trying to change pinned message for null participant. "+text);
            return;
        }
          String mostRecent = this.htMostRecentPinnedText.get(p);
          System.err.println("CHANGEPINNEDMESSAGE2"+text);

          if(mostRecent!=null ){
              System.err.println("CHANGEPINNEDMESSAGE3"+text);
              if(mostRecent.equals(text))return;
              System.err.println("CHANGEPINNEDMESSAGE4"+text);
              if(mostRecent.equalsIgnoreCase(text)){
                    System.err.println("CHANGEPINNEDMESSAGE5"+text);
                    org.telegram.telegrambots.meta.api.objects.Message m = (org.telegram.telegrambots.meta.api.objects.Message)this.htPinnedMessages.get(p);
                    if(m!=null){
                        System.err.println("CHANGEPINNEDMESSAGE6"+text);
                        c.telegram_sendEditMessageToParticipant(p, m, "processing move");
                        htMostRecentPinnedText.put(p,"--------------------");
                    }

              }
          }
         
           System.err.println("CHANGEPINNEDMESSAGE7"+text);
           org.telegram.telegrambots.meta.api.objects.Message m = (org.telegram.telegrambots.meta.api.objects.Message)this.htPinnedMessages.get(p);
           if(m!=null){
               System.err.println("CHANGEPINNEDMESSAGE8"+text);
               c.telegram_sendEditMessageToParticipant(p, m, text);
               htMostRecentPinnedText.put(p,text);
           }
           System.err.println("CHANGEPINNEDMESSAGE9"+text);
     }
    
    
    
     public void changePinnedMessageOLD(TelegramParticipant p,String text){
          String mostRecent = this.htMostRecentPinnedText.get(p);
          if(mostRecent!=null){
              if(mostRecent.equalsIgnoreCase(text))return;
          }
         
         
           org.telegram.telegrambots.meta.api.objects.Message m = (org.telegram.telegrambots.meta.api.objects.Message)this.htPinnedMessages.get(p);
           if(m!=null){
               c.telegram_sendEditMessageToParticipant(p, m, text);
               htMostRecentPinnedText.put(p,text);
           }
     }

    @Override
    public Vector<AttribVal> getAdditionalInformationForParticipant(Participant p) {
        PCTaskTG pctg=null;
        if(pctg!=null) return pctg.getAdditionalValues(p);
        return super.getAdditionalInformationForParticipant(p);
    }
    
    
    
    
    
    
   public static boolean showcCONGUI() {
        return true;
    }
    
   
   
   public PCTaskTG getPCTaskTGForParticipant(TelegramParticipant tp){
       return null;//q.getPCTaskTGForParticipant(tp);
   } 
   
   
   
   
   
   
}







